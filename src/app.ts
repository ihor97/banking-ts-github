// є дві черги перша - це кліки таймаути таймери і тд а друга суто проміси. 
// І проміси мають пріорітет перед ними(тобто спочатку спустошуються проміси а потім та черга з таймаутами)

// у цьому випадку браузер не поламається так як в нас все одно буде проміжки часу де ми можемо взаємодіяти з інтерфейсом
function loop1() {
    setTimeout(loop1);
}
// проміси хотя асинхронні теж але вони працюють там де макротаски(пріорітетний потік) і браузер впаде
// тобто буде постійно Callbackqueue засмічуватися 
// в минулому прикладі в нас був зазор часу коли колбек з webapi переходив callbackqueue
function loop2() {
    Promise.resolve().then(loop2)
}